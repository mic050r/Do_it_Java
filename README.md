# Do_it_Java

7/25  1. 자바 프로그래밍 시작하기
프로그래밍은 컴퓨터에게 일을 하도록 명령어를 만드는 것이다. 컴파일은 프로그램 언어를 컴퓨터가 알 수 있는 언어로 바꿔주는 일이다. 컴파일러는 기계어(0과 1)로 번역해 주는 프로그램이다. 자바를 설치하면 자바 컴파일러도 설치된다. 자바를 설치할 때 JDK는 최신 버전으로 JRE는 버전 8로 설치해야 한다. 패키지 이름은 소문자, 클래스 이름은 대문자로 만든다. 자바를 쓰면 좋은 이유는 첫 번째, 플랫폼에 영향을 받지 않으므로 다양한 환경에서 사용할 수 있다. 두 번째, 자바는 객체 지향 언어이기 때문에 유지 보수가 쉽고 확장성이 좋다. 세 번째, 프로그램이 안정적이고, 풍부한 기능을 제공하는 오픈소스이다.

7/26  2.변수와 자료형
컴퓨터는 2진수로 꺼지고 켜지는 반도체로 인식된다. bit(비트)는 컴퓨터가 표현하는 데이터의 최소 단위로 2진수 하나의 값을 저장할 수 있는 메모리의 크기이고, byte(바이트) 는 1byte = 8bit이다. 컴퓨터는 0과 1(2진수) 자료를 표현한다. 따라서 숫자나 문자도 0과 1의 조합으로 표현된다. 2진수로 표현하면 길이가 길어지므로 8진수나 16진수를 사용하기도 한다. 0B로 시작하는 것은 2진수이고, 0이 앞에 있는 것은 8진수 0X로 시작하는 것은 16진수이다. 정수의 가장 왼쪽에 존재하는 비트는 부호비트이다. MSB(Most Significant Bit) 가장 중요한 비트라는 뜻이다. 음수를 만드는 방법은 첫 번째, 2의 보수를 취한다. 두 번째, 1의 보수를 취한다. 세 번째, 1을 더한다.  앞이 0이명 양수 1이면 음수이다. 예를 들어 5를 -5를 바꾸면0000 0101->5, 1111 1010(1의 보수) + 1 -> 1111 1011 - > -5로 된다.

7/27 변수와 자료형 2
프로그래밍에서 값(Data)를 사용하기 위해 선언하는 것을 변수라 한다. 예를 들어 사람의 나이는 해가 바뀌면 변한다. (age), 두 수를 이용하여 사칙 연산을 하면 그 결과 값은 연산자에 따라 달라진다.(result), 게임을 하면 게임 레벨이 점점 올라간다.(level) 변수는 프로그램에서 사용되는 자료를 저장하기 위한 공간이고, 할당 받은 메모리의 주소 대신 부르는 이름이다. 또한 프로그램 실행 중에 값 변경 가능하다. 변수는 사용되기 이전에 선언되어야 한다. variable 이라 한다. 변수 선언 시 유의할 점이 있다. 첫 번째, 변수의 이름은 알파벳, 숫자, _,$로 구성된다. 두 번째, 대소문자를 구분한다. 세 번째, 변수의 이름은 숫자로 시작할 수 없고, 키워드도 변수의 이름으로 사용할 수 없다. 네 번째, 이름 사이에 공백이 있을 수 없다. 다섯 번째, 변수의 이름을 정할 때는 변수의 역할에 어울리는, 의미 있는 이름을 지어야 한다.  변수가 사용할 공간의 크기와 특성에 따라 자료 형을 사용하여 변수를 선언한다. ex) int num; 
int level; //level이라는 이름의 변수 선언
int level = 0; //level 변수 선언과 동시에 0으로 초기화
int level; 
level = 10;
int의 역할 : level 변수의 데이터 타입을 정의
int의 의미 : level은 정수이며 4바이트의 메모리 공간을 사용
정수형 byte(1바이트) ->short(2바이트)->int(4바이트)->long(8바이트)
문자형 char(2바이트)
실수형 float(4바이트) -> double(8바이트)
논리형 boolean(1바이트)
Byte는 1바이트 단위의 자료 형이다. 동영상, 음악 파일 등 실행 파일의 자료를 처리할 때 사용하기 좋은 자료 형이다. Short는 2바이트 단위의 자료 형이다. 주로 c/c++ 언어와의 호환 시 사용한다. Int는 자바에서 사용하는 정수에 대한 기본 자료 형이다. 4바이트 단위의 자료 형이고, 프로그램에서 사용하는 모든 숫자(리터럴)은 기본적으로 int(4바이트)로 저장된다. 32비트를 초과하는 숫자는 long 형으로 처리해야한다. Long은 8바이트 자료 형이다. 가장 큰 정수 자료 형이고, 숫자의 뒤에 L또는 l을 써서 long형임을 표시해야 한다.
ex) int num = 12345678900;  //오류남 int의 범위 넘은 값 대입
long num = 12345678900;   //오류남
=>숫자(리터럴) 12345678900을 long으로 처리하도록 명시 
long num = 12345678900L;   //ok소문자 l을 써도 되지만
//1과 구분하기 위해 대문자로 씀
Char는 문자 자료 형이고 컴퓨터에서는 문자도 내부적으로는 비트의 조합으로 표현 자바에서는 문자를 2바이트로 처리한다.
인코딩 - 각 문자에 따른 특정한 숫자 값(코드 값)을 부여 
디토딩- 숫자 값을 원래의 문자로 변환
문자세트 : 문자를 위한 코드 값(숫자 값) 들을 정해 놓은 세트
아스키(ASCII) : 1바이트로 영문자, 숫자, 특수문자 등을 표현 
유니코드(Unicode) : 한글과 같은 복잡한 언어를 표현하기 위한 표준 인코딩 UTF-8, UTF-16이 대표적
(https://www.unicode.org/charts/PDF.UAC00.pdf 참고)
문자를 변수에 저장하면? 문자에 해당하는 코드 값이 저장된다. 자바는 유니코드 UTF-16 인코딩을 사용한다. 
부동 소수점 방식: 실수를 지수부와 가수부로 표현
무한의 실수를 표현하기 위한 방식 
실수는 기본적으로 double형으로 처리한다. float형으로 사용하는 경우 f, F를 명시 한다. Boolean은 논리형이고, 논리값 true(참), false(거짓)을 표현할 때 선언된다.
자료 형이 필요한 이유는 변수를 선언 할 때는 변수가 사용할 메모리 크기와 타입을 구분하기 위해서이다. 
지역 변수 자료 형 추론(local variable type inference) : 변수에 대입되는 값을 보고 컴파일러가 추론

7/28 상수
✓상수
상수 : 변하지 않는 값(cf 변수 : 변하는 값)
상수를 선언 : final 키워드 사용
final double PI = 3.14;
final int MAX_NUM = 100;
final로 선언된 상수는 다른 값을 대입 할 수 없음
PI = 3.15;  //에러남
프로그램 내에서 변경되지 말아야 하는 값을 상수로 선언 해 두고 혹시 변경되는 경우 선언된 값만 수정
✓리터럴(literal)
리터럴 : 프로그램에서 사용하는 모든 숫자, 값, 논리 값
ex) 10, 3.14, 'A', true
리터럴에 해당되는 값은 특정 메모리 공간인 상수 풀(constant pool)에 있음
필요한 경우 상수 풀에서 가져와서 사용
상수풀에 저장 할 때 정수는 int로 실수는 double로 저장
따라서 long이나 float 값으로 저장해야 하는 경우 식별자(L, l, F, f)를 명시해야 함 
리터럴(숫자, 문자, 논리값...)->로딩->상수 풀(10,a,3.14)->대입/복사->변수(num = 3)
✓형 변환(type conversion)
자료 형은 각각 사용하는 메모리 크기와 방식이 다름
서로 다른 자료 형의 값이 대입되는 경우 형 변환이 일어남
→묵시적 형 변환 : 작은 수에서 큰 수로 덜 정밀한 수(정수)에서 더 정밀한 수(실수)로 대입되는 경우, 자연스럽게 형 변환이 이루어 지는 것
ex) long num = 3; //int 값에서 long으로 자동 형 변환
// L, l 을 명시하지 않아도 됨
ㅊ명시적 형 변환 : 묵시적 형 변환의 반대의 경우 변환되는 자료 형을 명시해야 함. 자료의 손실이 발생 할 수 있음. 
ex) double dNum = 3.14;
int num = (int)dNum; //자료형 명시

7/29 자바의 여러 가지 연산자
✓항과 연산자
항(operand) : 연산에 사용되는 값
연산자(opertor) : 항을 이용하여 연산하는 기호
✓항의 개수에 따른 연산자 구분
연산자 : 단항연산자 -항이 한 개인 연산자 ex) ++num
이항 연산자 : 항이 두 개인 연산자 ex) num1 + num2;
삼항 연산자 : 항이 세 개인 연산자 ex) (5>3)? 1 : 0;
✓대입 연산자
→변수에 값을 대입 하는 연산자
연산의 결과를 변수에 대입
우선 수위가 가장 낮은 연산자
왼쪽 변수(lvalue)에 오른쪽 변수(값)(rvalue)를 대입
int age = 24; //나이를 의미하는 age 변수에 값 24를 대입한
totalScore = mathScore + engScore //1mathScore 값과 영어 점수 engScore 값을 더하여
//2총점을 의미하는 tatalScore변수에 수학 점수에 대입함
✓부호 연산자
→단항 연산자
양수/음수의 표현, 값의 부호를 변경
+ : 변수나 상수 값을 양수로 만듭니다 ex) +3
- : 변수나 상수 값을 음수로 만듭니다. ex)-3
변수에 +, -를 사용한다고 해서 변수의 값이 변하는 것은 아님
변수의 값을 변경하려면 대입연사자를 사용해야함
✓산술 연산자
→사칙 연산에 사용되는 연산자
+ : 두 항을 더합니다. ex) 5+3
- : 앞에 있는 항에서 뒤에 있는 항을 뺍니다. ex)5-3
* : 두 항을 곱합니다. ex)5*3
/ : 앞에 있는 항에서 뒤에 있는 항을 나누어 몫을 구합니다. ex)5/3
% : 앞에 있는 항에서 뒤에 있는 항을 나누어 나머지를 구합니다. ex)5%3
★%는 나머지를 구하는 연산자
=>숫자 n의 나머지는 0~n-1 범위의 수
=>특정 범위 안의 수를 구할 때 종종 사용
✓증가 감소 연산자
→단항 연산자 
→1만큼 더하거나 1만큼 뺄 때 사용하는 연산자
항의 앞/뒤 위치에 따라 연산의 결과가 달라짐에 유의
; ->문장이 끝났다는 뜻
++ : 항의 값에 1을더합니다. val = ++num //먼저 num 값이 1 증가한 후 val 변수에 대입 =>문장이 끝나기 전에 더해라
val = num++; //val 변수에 기존 num 값을 먼저 대입한 후 num 값 1 증가 =>문장이 끝나고 나서 더해라
-- : 항의 값에서 1을 뺍니다.  val = --num; //먼저 num 값이 1 감소한 후 val 변수에 대입=>문장이 끝나기 전에 빼라
val = num--; //val 변수에 기존 num 값을 먼저 대입한 후 num 값 1감소=>문장이 끝나고 나서 더해라
✓관계 연산자
→이항 연산자
연산의 결과가 true(참), false(거짓)으로 반환 됨
> : 왼쪽 항이 크면 참을, 아니면 거짓을 반환합니다. ex) num >3;
< : 왼쪽 항이 작으면 참, 아니면 거짓을 반환합니다. ex) num <3;
>= : 왼쪽 항이 오른쪽 항보다 크거나 같으면 참, 아니면 거짓을 반환합니다.
<= : 왼쪽 항이 오른쪽 항보다 작거나 같으면 참, 아니면 거짓을 반환합니다. ex) num<=3;
== : 두 개 항의 값이 같으면 참, 아니면 거짓을 반환합니다. ex) num ==3;
!= : 두 개 항이 다르면 참, 아니면 거짓을 반환합니다. ex)num !=3;
✓논리 연산자
관계 연산자와 혼합하여 많이 사용됨
연산의 결과가 true(참), false(거짓)으로 반환 됨
&&(논리 곱) : 두 항이 모두 참인 경우에만 결과 값이 참입니다. 그렇지 않은 경우는 거짓입니다. ex) booleanval = (5>3) && (5>2);
|| (논리 합) : 두 항 중 하나의 항만 참이면 결과 값은 참이 빕니다. 두 항이 모두 거짓이면 결과 값은 거짓입니다. ex) booleanval = (5>3) || (5<2);
!(부정) : 단항 연산자입니다. 참인 경우는 거짓으로 바꾸고, 거짓인 경우는 참으로 바꿉니다. ex) booleanval =! (5>3);
✓단락 회로 평가(short circuit evaluation)
논리 곱 (&&)은 두 항이 모두 true일 때만 결과가 true
=> 앞의 항이 false 이면 뒤 항의 결과를 평가하지 않아도 false임
논리 합(||)은 두 항이 모두 false 일 때만 결과가 false
=> 앞의 항의 true이면 뒤 항의 결과를 평가하지 않아도 true임 

8/1 자바의 여러 가지 연산자(2)
✓복합 대입 연산자 
→대입 연산자와 다른 연산자를 함께 사용함
프로그램에서 자주 사용하는 연산자
연산자
+= : 두 항의 값을 더해서 왼쪽 항에 대입합니다. ex) num1 += 2; num1 = num1 +2;와 같음
-= : 왼쪽 항에서 오른쪽 항을 빼서 그 값을 왼쪽 항에 대입합니다. ex)num1 -= 2; num1 = num1 -2;와 같음
*= : 두 항의 값을 곱해서 왼쪽 항에 대입합니다. ex)num1 *=2; num1 = num1*2;와 같음
/= : 왼쪽 항을 오른쪽 항으로 나누어 그 몫을 왼쪽 항에 대입합니다. ex)num1 /=2; num1 = num1/2; 와 같음
%= : 왼쪽 항을 오른쪽 항으로 나누어 그 나머지를 왼쪽항에 대입합니다. ex)num1 %=2; num1 = num1%2; 와 같음
✓복합 대입 연산자
<<= : 비트를 왼쪽으로 이동하고 그 값을 왼쪽 항에 대입합니다. ex)num1<<=2; num1 = num1<<2;와 같음
>>= : 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입합니다(왼쪽에 채워지는 비트 값은 부호 비트와 동일합니다.) num1 >>=2; num1 = num1>>2;와 같음
>>>= : 비트를 오른쪽으로 이동하고 그 값을 왼쪽 항에 대입합니다(왼쪽에 채워지는 비트 값은 0입니다.) ex)num1>>>2; num1 = num1>>>2;와 같음
&= : 두 항의 & 비트 연산 후 그 값을 왼쪽 항에 대입합니다. ex)num1&2; num1 = num1&2;와 같음
|= : 두 항의 | 비트 연산 후 그 값을 왼쪽 항에 대입합니다. ex)num1|2; num1 = num1|2;와 같음
^= : 두 항의 ^비트 연산 후 그 값을 왼쪽 항에 대입합니다. ex)num1^2; num1 = num1^2;와 같음
✓조건 연산자
삼항 연산자
조건 식의 결과가 true(참)인 경우와 false(거짓)인 경우에 따라 다른 식이나 결과가 수행됨
제어문 중 조건문을 간단히 표현할 때 사용할 수 있음
연산자 : 조건식 ? 결과1 : 결과2; 
기능 : 조건식이 참이면 결과1, 조건식이 거짓이면 결과2가 선택됩니다
연산 예 : int num = (5>3) ? 10 : 20;
✓비트 연산자
~ : 비트의 반전(1의 보수) ex)a = ~a;
& : 비트의 단위(AND) ex)1&1 1반환 그 외는 0
| : 비트 단위 OR ex)0|0 0반환 그 외는 1
^ : 비트 단위 XOR ex)두 개의 비트가 서로 다른 경우에 1을 반환
<< : 왼쪽 shift ex)a<<2 변수 a를 2비트 만큼 왼쪽으로 이동 //2의 n승 만큼 곱해짐 15<<2 =>15*4
>> : 오른쪽 shift ex)a>>2 변수 a를 2비트 만큼 오른쪽으로 이동 //2의 n승 만큼 나눠짐
>>> : 오른쪽 shift ex)>>동일한 연산 채워지는 비트가 부호와 상관없이 0임
비트 연산자는 정수에만 사용할 수 있다.
✓비트 연산자의 활용
마스크 : 특정 비트들은 가리고 몇 개의 비트들의 값만 사용할 때
비트 켜기 : 특정 비트들만을 1로 설정해서 사용하고 싶을 때 ex) &00001111(하위 4비트 중 1인 비트만 꺼내기)
비트 끄기 : 특정 비트들만을 0으로 설정해서 사용하고 싶을 때 
ex) |11110000(하위 4비트 중 0인 비트만 0으로 만들기)
비트 토글 : 모든 비트들을 0은 1로, 1은 0으로 바꾸고 싶을 때


8/2 제어의 흐름 이해하기 
✓조건문
→주어진 조건에 따라 다른 수행문이 실행되도록 프로그래밍 하는 것
✓if문
if(조건식) {
     수행문;
}
✓if-else문
if(조건식) {
     수행문1; //참이면
}else{
     수행문2; //거짓이면
}
수행문이 하나만 있으면 중괄호 안 써도 됨
BUT 가동성을 위해 쓰는 것이 좋다
✓if-else if-else 문
하나의 경우에 조건이 여러개에 해당하는 경우
if(조건 1)
{
   문장 1:
}else if(조건 2)
{
    문장2:
}else if(조건 3)
{
    문장 3:
}
else 
{
    문장 4:
}
+ => 출력문에서 +를 사용하면 여러 단어를 연결하여 출력할 수 있음. 
✓조건문과 조건 연산자
간단한 if-else조건문은 조건 연산자로 구현할 수 있음
if(a>b)
  max = a;
else
   max = b;
(if-else문)
=> max = (a >b) ? a: b; (조건연산자)
✓switch-case문
조건식의 결과가 정수 또는 문자열의 값이고 그 값에 따라 수행문이 결정될 때
if-else if-else문을 대신하여 switch-case문을 사용할 수 있음. 
조건에 대한 값이 간단한 정수값, 문자열 일 때 쓰이면 좋음
ex) 순위에 따른 메달의 색을 정해주는 코드 switch-case문으로 구현 가능
break를 써주는 것이 중요
✓case문에 문자열 사용하기
자바7부터 switch-case문의 case 값에 문자열 사용 가능





8/3 반복문
주어진 조건이 만족 할 때 까지 수행문을 반복적으로 수행함
while, do-while, for문이 있음
조건의 만족과 반복 가능 여부에 대해 정확한 코딩을 해야함
✓while문
조건식이 참인 동안 수행 문을 반복해서 수행
while(조건식) {
   수행문1; //참일때
    ...
}
   수행문2; //거짓일때
    ...
✓do wihle문 
먼저 수행문을 한 번 수행하고 조건식 체크
수행문이 반드시 한 번 이상 수행 되어야 하는 경우 사용
do {
  수행문1;
   ...
}while(조건식);
   수행문2;
    ...
✓for문
반복문 중 가장 많이 사용하는 반복문
주로 조건이 횟수인 경우에 사용
초기화식, 조건식, 증감식을 한꺼번에 작성
for(초기화식; 조건식; 증감식) {
    수행문;
}
✓for문 수행 과정
num이 1에서 부터 5일 때 까지 하나씩 증가하면서 출력하는 for문
✓각 반복문의 쓰임
while문 : 하나의 조건에 대해 반복수행이 이루어질 때 사용 
조건이 맞지 않으면 수행문이 수행되지 않음 
주로 조건식이 true, false로 나타남
do-while문 : 하나의 조건에 대해 반복수행이 이루어질 때 사용 
단, 수행문이 반드시 한 번 이상 수행됨
for문 : 수의 특정 범위, 횟수와 관련한 반복수행에서 주로 사용
중첩된 반복문
반복문 내부에 또 반복문이 사용 됨
ex) 구구단
System.out.println(); //한 줄 띄어서 출력
✓continue문
반복문과 함께 쓰이며, 반복문 내부 continue문을 만나면 이후 반복되는 부분을 수행하지 않고 조건식이나 증감식을 수행함
ex)1부터 100까지 중 홀수만 더하기
✓break문
반복문에서 break 문을 만나면 더 이상 반복을 수행하지 않고 반복문을 빠져 나옴
중첩된 반복문 내부에 있는 경우 가장 가까운 반복문 하나만 빠져 나옴
while(조건식1) {
  while(조건식2) {
   if(조건식)  //조건에 해당하는 경우 
   break; // 내부 반복문만 빠져나옴
   }
}
ex) 0부터 시작하여 1씩 늘리며 숫자의 합이 100이 초과하는 경우 그 수와 합을 구하는 예제 



8/4 클래스와 객체1
✓객체 지향프로그래밍과 클래스
객체란(Object)란?
"의사나 행위가 미치는 대상" -사전적 의미
구체적, 추상적 데이터 단위
객체지향 프로그래밍(Object Oriented Programming, OOP)
객체를 기반으로 하는 프로그래밍
cf. 절차프로그래밍(Procedural Prigramiing ex) C언어)
객체지향 프로그램=> 시간의 순서 중요X
✓생확 속의 객체 예
학교 가는 과정에 대한 절차적 프로그래 밍
-일어난다 -> 씻는다 -> 밥을 먹는다 -> 버스를 탄다 -> 요금을 지불한다 -> 학교에 도착한다.
절차 지향 프로그램 =>시간의 흐름에 따른 프로그래밍 =>순차적인 프로그래밍 
학교 가는 과정에 대한 객체 지향 프로그래밍
객체를 정의
어떤 대상이 있는지 중요
대상이 무슨 기능을 하는지 
객체지향이 더 현실적
✓객체의 기능 구현
객체 사이의 협력 구현
학생 -> 먹는다 -> 밥
학생 - > 탄다 -> 버스
학생 - > 간다 -> 학교
✓클래스(class)
클래스란?
객체에 대한 속성과 기능을 코드로 구현 한 것
"클래스를 정의 한다" 라고 함
객체에 대한 청사진(blueprint)
객체의 속성
객체의 특성, 속성, 멤버 변수
property, attribute, member variable
✓객체의 기능 
객체가 하는 기능들을 메서드로 구현
method, member function
클래스 정의 하기
(접근 제어자) class 클래스 이름{
  멤버 변수;
   메서드;
}
✓학생 클래스의 예
속성 : 학번, 이름, 학년, 사는 곳 등등..
기능 : 수강신청, 수업듣기, 시험 보기 등등..
클래스 정의 하기
class는 대부분 대문자로 시작
하나의 java파일에 하나의 클래스를 두는 것이 원칙이나, 여러 개의 클래스가 같이 있는 경우 public 클래스는 단 하나이며, public 클래스와 자바 파일의 이름은 동일해야 함
자바의 모든 코드는 class 내부에 위치
✓클래스의 속성
클래스의 특징을 나타냄
property, attribut라고도 함
자료형을 이용하여 멤버 변수로 선언
속성 - 자료형 - 변수 이름 - 설명
학번 - int - studentID-학변은 정수로 나타낼 수 있기 때문에 int형으로 선언함
이름 - String - studentName - 학생 이름은 문자로 되어있음. 그런데 이름은 A같은 하나의 문자가 아니라 여러 개의 문자로 이루어진 문자열로 표현함. 문자열은 자바에서 제공하는 String 클래스를 사용함
학년 - int- grade - 학년은 정수로 나타낼 수 있기 때문에 int형으로 선언함
사는 곳 - String - address - 문자열을 나타내기 위해 String을 사용함
✓클래스의 기능
메서드(method)의 구현
멤버 함수(member function)라고도 함
객체가 수행하는 기능을 구현
✓패키지란?
간단하게 말하자면 소스의 묶음
패키지 이름은 성격을 나타내는 역할
클래스를 구분해주는 기능도 있음
소스 코드를 어떠한 계층 구조로 관리할 수 있는지 구성할 수 있는 것


8/5
✓메서드
함수의 일종
객체의 기능을 제공하기 위해 클래스 내부에 구현되는 함수
✓함수란?
하나의 기능을 수행하는 일련의 코드
중복되는 기능은 함수로 구현하여 함수를 호출하여 사용함
더하기 함수 -> 숫자 두개를 입력받아 더한다
                ->가장 좋은 성적 두개를 더한다
                 -> 두 거리를 더한다
=>함수를 호출한다라고 말한다
✓함수 
입력(숫자, 성적, 거리...) -> 더하기 함수 -> 출력(숫자의 합, 성적의 합, 거리의 합....)
=> num1, num2(매개변수)-> add함수(함수이름) result = num1 + num2 ->result(반환값)
✓함수 정의 하기
함수를 코드로 구현 
함수를 코드로 구현
함수의 이름, 매개변수, 반환값을 선언하고 코드를 구현함
1.	함수이름 : 함수의 기능과 관련하여 명명
2.	매개 변수 : 함수의 수행을 위해 필요한 변수
3.	return : 함수 수행 결과를 반환하기 위한 예약어
4.	함수 반환 형 : 반환 값의 자료형을 나타냄. 반환값이 없는 경우 void라고 씀
함수 구현하고 호출하기
add( ) 함수 호출
add( ) 함수
return result; // 결과 값 반환
✓함수와 스택 메모리
함수가 호출 될 때 사용하는 메모리 -스택(stack)
함수의 기능 수행이 끝나면 자동으로 반환되는 메모리
함수 호출과 스택 메모리 구조
main ( ) -> addNum( )
스택의 구조 택배 상자 같은 구조 
num1, num2, sum ->main( )
n1, n2, result -> addNum() //변수이름 달라도 상관없음
메모리 구조가 끝나면(함수의 호출이 끝나면)
main만 남게 된다
✓클래스에 메서드 구현하기
✓함수를 사용하는 이유
1.	코드를 효율적으로 사용하기 위해서
2.	유지보수하는데 좋음
3.	함수 구현 제한 없음
4.	하나의 기능을 함수의 이름에 맞게 구현하는 것이 적절하다
 
8/8~ 8/12
클래스와 객체1 (3)
✓class&instance
클래스(static 코드) -> 생성(인스턴스 화)-> 인스턴스(dynamic memory)
✓클래스 생성하기
클래스를 사용하기 위해서는 클래스를 생성하여아 함
new 예약어를 이용하여 클래스 생성
클래스형 변수 이름 = new 생성자;
Student studentA = new Student();
 int i = 10; 기본형 데이터 타입
Student studentA = new Student(); 참조 형 데이터 타입
✓인스턴스와 힙(heap) 메모리
하나의 클래스 코드로부터 여러 개의 인스턴스를 생성
인스턴스는 힙(Heap) 메모리에 생성됨
각각의 인스턴스는 다른 메모리에 다른 값을 가짐
✓클래스, 인스턴스, 참조 변수, 참조 값
객체 : 객체 지향 프로그램의 대상, 생성된 인스턴스
클래스 : 객체를 프로그래밍하기 위해 코드로 만든 상태
인스턴스 : 클래스가 메모리에 생성된 상태
멤버 변수 : 클래스의 속성, 특성
메서드 : 멤버 변수를 이용하여 클래스의 기능을 구현
참조 변수 : 메모리에 생성된 인스턴스를 가리키는 변수
참조 값 : 생성된 인스턴스의 메모리 주소 값
✓생성자(constructor)
인스턴스 생성 시 new 키워드와 함께 사용했던 생성자
✓생성자 기본 문법
<modifiers><class_name>([<argument_list>])
{
   [<statements>]
}
생성자는 인스턴스를 초기화 할 때의 명령어 집합
생성자의 이름은 그 클래스의 이름과 같음
생성자는 메소드가 아님. 상속되지 않으며, 리턴 값은 없음
✓디폴트 생성자(default constructor)
하나의 클래스에는 반드시 적어도 하나 이상의 Constructor가 존재
프로그래머가 Constructor 를 기술하지 않으면 Default
Constructor가 자동으로 생김(컴파일러가 코드에 넣어 줌)
Default Constructor는 매개 변수가 없음
Default Constructor는 구현부가 없음
만약 클래스에 매개변수가 있는 생성자를 추가하면 디폴트 생성자는 제공되지 않음
✓생성자 오버로드(constructor overload)
필요에 의해 생성자 추가 하는 경우 여러 개의 생성자가 하나의 클래스에 있음(overload)

클래스와 객체2 (1)
✓this(예약어)가 하는일
자신의 메모리를 가리킴
생성자에서 다른 생성자를 호출
자신의 주소를 반환함
자신의 메모리를 가리키는 this
생성된 인스턴스 스스로를 가리키는 예약어
public Person(String name, int age) {
  this.name = name;
  this.age = age;
}
note : 위 코드에서 this를 생략하게 되면 name이나 age는 파라미터로 사용되는 name과 age로 인식된다.
✓생성자에서 다른 생성자를 호출 하는 this
public Person(){
  this("이름없음",1);
}
public Person(String name, int age) {
  this.name = name;
  this.age = age;
}
note : this를 이용하여 다른 생성자를 호출할 때는 그 이전에 어떠한 statement도 사용할 수 없다. 
위와 같이 생성자가 여러 개이고 파라미터만 다른 경우 constructor overloading이라고 한다.

클래스와 객체2 (2)
✓객체 간의 협력
학생이 버스나 지하철을 가는 상황을 객체 지향으로 프로그래밍
학생[이름, 학년, 가진돈] ->버스를 탄다 ->버스[버스 번호, 승객 수, 수입]
학생[이름, 학년, 가진돈] -> 지하철을 탄다 -> 지하철[노선 번호, 승객 수, 수입]
take() :추상 메서드

클래스와 객체2(3) - static 변수
✓static 변수
static 변수의 정의와 사용 방법
static(static 예약어) int(자료형) serialNum(변수이름);
여러개의 인스턴스가 같은 메모리의 값을 공유하기 위해 사용
static 변수 : 인스턴스가 생성될 때 마다 다른 메모리를 가지는 것이 아니라 프로그램이 메모리에 적재(load) 될 때 에이터 영역의 메모리에 생성됨
따라서 인스턴스의 생성과 관계없이 클래스 이름으로 직접 참조 함
Student.serialNum = 100; //serailNum이 static 변수
클래스 변수라고도 함 //참조변수말고 클래스변수가 더 나음
멤버 변수는 다른 말로 인스턴스 변수라고 함
✓static 변수 VS 인스턴스 변수
Student - +serailNumber = 1001; -studentID;
-std1: Student - studentID = 1002
-std2 :Student - studentID = 1003
note : serialNumber를 static으로 선언하면 모든 student instance 에 대해 하나의 변수로 유지 되고 이런한 변수를 class변수라 한다.
✓static 변수 예
여러 인스턴스가 하나의 메모리 값을 공유 할 때 필요
학생이 생성될 때마다 학번이 증가해야 하는 경우
기준이 되는 값은 static 변수로 생성하여 유지함
각 학생이 생성될 때 마다 static 변수 값을 복사해 와서 하나 증가시킨 값을 생성된 인스턴스의 학번 변수에 저장해줌
변수유형	선언 위치	사용 범위	메모리	생성과 소멸
지역 변수
(로컬 변수)	함수 내부에 선언	함수 내부에서만 사용	스택	함수가 호출 될 때 생성되고 함수가 끝나면 소멸함
멤버 변수
(인스턴스 변수)	클래스 멤버 변수로 선언	클래스 내부에서 사용하고 private이 아니면 참조 변수로 다른 클래스에서 사용 가능	힙	인스턴스가 생성될 때 힙에 생성되고, 가비지 컬렉터가 메모리를 수거할 때 소멸됨
static변수
(클래스 변수)	Static 예약어를 사용하여 클래스 내부에 선언	클래스 내부에서 사용하고 private이 아니면 다른 클래스에서 사용 가능	데이터 영역	프로그램이 처음 시작 할 때 상수와 함께 데이터 영역에 생성되고 프로그램이 끝나고 메모리를 해제할 때 소멸됨

